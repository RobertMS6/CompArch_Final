$date
	Sat Apr  5 11:25:11 2014
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module processor_tb $end
$scope module test $end
$var wire 4 ! ALU_ctr_out [3:0] $end
$var wire 32 " ALU_out [31:0] $end
$var wire 32 # ALUsrc_out [31:0] $end
$var wire 1 $ clk $end
$var wire 10 % control_logic [9:0] $end
$var wire 32 & imm_extend [31:0] $end
$var wire 32 ' instruction [31:0] $end
$var wire 32 ( newPC [31:0] $end
$var wire 32 ) rDataA [31:0] $end
$var wire 32 * rDataB [31:0] $end
$var wire 32 + rMemData [31:0] $end
$var wire 5 , wAddr [4:0] $end
$var wire 32 - wData [31:0] $end
$var wire 1 . zero $end
$var reg 32 / ALU_inA [31:0] $end
$var reg 32 0 ALU_inB [31:0] $end
$var reg 2 1 ALU_op [1:0] $end
$var reg 1 2 ALUsrc_sel $end
$var reg 1 3 MemWrite_sel $end
$var reg 1 4 MemtoReg_sel $end
$var reg 5 5 RegDest_inB [4:0] $end
$var reg 5 6 RegDst_inA [4:0] $end
$var reg 1 7 RegWrite_sel $end
$var reg 1 8 branch_sel $end
$var reg 6 9 func_code [5:0] $end
$var reg 16 : imm [15:0] $end
$var reg 1 ; jump_sel $end
$var reg 1 < memRead_sel $end
$var reg 6 = opcode [5:0] $end
$var reg 32 > pc [31:0] $end
$var reg 5 ? rAddrA [4:0] $end
$var reg 5 @ rAddrB [4:0] $end
$var reg 1 A regDst_sel $end
$scope module regsister $end
$var wire 1 B clk $end
$var wire 5 C rAddrA [4:0] $end
$var wire 5 D rAddrB [4:0] $end
$var wire 5 E wAddr [4:0] $end
$var wire 32 F wData [31:0] $end
$var wire 1 G writeEn $end
$var reg 32 H rDataA [31:0] $end
$var reg 32 I rDataB [31:0] $end
$upscope $end
$scope module control $end
$var wire 6 J opcode [5:0] $end
$var reg 10 K out [9:0] $end
$upscope $end
$scope module RegDst $end
$var wire 5 L inA [4:0] $end
$var wire 5 M inB [4:0] $end
$var wire 1 N sel $end
$var reg 5 O out [4:0] $end
$upscope $end
$scope module MemtoReg $end
$var wire 32 P inA [31:0] $end
$var wire 32 Q inB [31:0] $end
$var wire 1 R sel $end
$var reg 32 S out [31:0] $end
$upscope $end
$scope module ALUsrc $end
$var wire 32 T inA [31:0] $end
$var wire 32 U inB [31:0] $end
$var wire 1 V sel $end
$var reg 32 W out [31:0] $end
$upscope $end
$scope module immediate $end
$var wire 16 X extend [15:0] $end
$var reg 32 Y extended [31:0] $end
$upscope $end
$scope module ALU_unit $end
$var wire 4 Z ALUCtrl [3:0] $end
$var wire 32 [ inA [31:0] $end
$var wire 32 \ inB [31:0] $end
$var reg 32 ] ALUResult [31:0] $end
$var reg 1 ^ zero $end
$upscope $end
$scope module ALU_ctrl_unit $end
$var wire 2 _ ALUop [1:0] $end
$var wire 6 ` funct [5:0] $end
$var reg 4 a out [3:0] $end
$upscope $end
$scope module j $end
$var wire 32 b addrTemp [31:0] $end
$var wire 32 c bInstr [31:0] $end
$var wire 1 d branch_sel $end
$var wire 32 e instruction [31:0] $end
$var wire 32 f jInstr [31:0] $end
$var wire 1 g jump_sel $end
$var wire 32 h newPC [31:0] $end
$var wire 32 i pc [31:0] $end
$var wire 1 . zero $end
$var reg 32 j bInstrTemp [31:0] $end
$var reg 1 k branch_ctl $end
$var reg 16 l instrTemp [15:0] $end
$var reg 32 m jInstrTemp [31:0] $end
$var reg 32 n pcTemp [31:0] $end
$scope module bTemp $end
$var wire 16 o extend [15:0] $end
$var reg 32 p extended [31:0] $end
$upscope $end
$scope module branchMux $end
$var wire 32 q inA [31:0] $end
$var wire 32 r inB [31:0] $end
$var wire 1 s sel $end
$var reg 32 t out [31:0] $end
$upscope $end
$scope module jumpMux $end
$var wire 32 u inA [31:0] $end
$var wire 32 v inB [31:0] $end
$var wire 1 g sel $end
$var reg 32 w out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bz00 w
bz00 v
bx u
bx t
xs
bx r
bx q
bz p
bz o
bx n
bz00 m
bz l
xk
bx j
bx i
bz00 h
xg
bz f
bz e
xd
bz c
bx b
bx a
bx `
bx _
1^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
xV
bx U
bx T
bz S
xR
bz Q
bx P
bx O
xN
bx M
bx L
bx K
bx J
bx I
bx H
xG
bz F
bx E
bx D
bx C
zB
xA
bx @
bx ?
bx >
bx =
x<
x;
bx :
bx 9
x8
x7
bx 6
bx 5
x4
x3
x2
bx 1
bx 0
bx /
1.
bz -
bx ,
bz +
bx *
bx )
bz (
bz '
bx &
bx %
x$
bx #
bx "
bx !
$end
